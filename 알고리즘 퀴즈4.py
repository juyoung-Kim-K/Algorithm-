##문제 4번
##Q4. 아래 회의 목록이 주어졌을 때, **탐욕 알고리즘(종료 시간 기준 정렬)**을 사용하여 겹치지 않게 최대한 많은 회의를 선택하시오. 선택된 회의 목록과 선택 기준을 설명하시오.


##주어진 회의시간
meetings = [
    (9, 9.75),   # 회의 A: 09:00~09:45
    (9.5, 10.5), # 회의 B: 09:30~10:30
    (10, 10.33), # 회의 C: 10:00~10:20
    (10.5, 11),  # 회의 D: 10:30~11:00
    (11, 12),    # 회의 E: 11:00~12:00
    (9.25, 10),  # 회의 F: 09:15~10:00
    (13, 13.5),  # 회의 G: 13:00~13:30
    (12.5, 13.5),# 회의 H: 12:30~13:30
    (14, 15),    # 회의 I: 14:00~15:00
    (15, 16)     # 회의 J: 15:00~16:00
]

## 종료 시간을 기준으로 모든 회의시간을 정렬시킴
sorted_meetings = sorted(meetings, key=lambda x: x[1])

## 선택된 회의 리스트
selected = []
current_end = 0

for start, end in sorted_meetings:          
    if start >= current_end:                #현재 회의의 시작 시간이 이전 회의의 종료 시간보다 같거나 늦다면, 두 회의는 겹치지 않음
        selected.append((start, end))           
        current_end = end           
        
'''
코드의 아쉬운점: 시간적인 여유나 비대면이 아닌 대면회의인 경우에는 실제로 그 시간 텀이라는 것이 중요한데 위에 코드는 시간 텀은 고려없이 정렬된 상태에서 가장 첫번째인 회의를 채택하고 그 다음 올 회의를 찾는 것에만 집중됨        
그래서 최적의 회의 시간 도출에 가깝다고는 볼 수 없다고 생각함.
'''

## 결과 출력
print("선택된 회의 수:", len(selected))
print("선택된 회의 목록:", selected)

##출력 결과
##선택된 회의 수: 7
##선택된 회의 목록: [(9, 9.75), (10, 10.33), (10.5, 11), (11, 12), (13, 13.5), (14, 15), (15, 16)]